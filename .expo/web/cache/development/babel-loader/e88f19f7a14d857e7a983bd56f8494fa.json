{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport PropTypes from 'prop-types';\nimport Svg from 'react-native-svg';\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport Path from \"../animated-path\";\n\nvar StackedBarGrouped = function (_PureComponent) {\n  _inherits(StackedBarGrouped, _PureComponent);\n\n  var _super = _createSuper(StackedBarGrouped);\n\n  function StackedBarGrouped() {\n    var _this;\n\n    _classCallCheck(this, StackedBarGrouped);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      width: 0,\n      height: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"coordinatesToPathCommands\", function (x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder) {\n      var commands = [];\n      commands.push({\n        marker: 'M',\n        values: [x0, y0]\n      });\n\n      if (showTopBorder) {\n        var topLeft1 = [x0 + borderRadius, y0];\n        var topLeft2 = [x0, y0 + borderRadius];\n        commands.push({\n          marker: 'L',\n          values: topLeft1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(topLeft1, [x0, y0], topLeft2)\n        });\n        commands.push({\n          marker: 'L',\n          values: topLeft2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x0, y0]\n        });\n      }\n\n      if (showBottomBorder) {\n        var bottomLeft1 = [x0, y1 - borderRadius];\n        var bottomLeft2 = [x0 + borderRadius, y1];\n        commands.push({\n          marker: 'L',\n          values: bottomLeft1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(bottomLeft1, [x0, y1], bottomLeft2)\n        });\n        commands.push({\n          marker: 'L',\n          values: bottomLeft2\n        });\n        var bottomRight1 = [x1 - borderRadius, y1];\n        var bottomRight2 = [x1, y1 - borderRadius];\n        commands.push({\n          marker: 'L',\n          values: bottomRight1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(bottomRight1, [x1, y1], bottomRight2)\n        });\n        commands.push({\n          marker: 'L',\n          values: bottomRight2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x0, y1]\n        });\n        commands.push({\n          marker: 'L',\n          values: [x1, y1]\n        });\n      }\n\n      if (showTopBorder) {\n        var topRight1 = [x1, y0 + borderRadius];\n        var topRight2 = [x1 - borderRadius, y0];\n        commands.push({\n          marker: 'L',\n          values: topRight1\n        });\n        commands.push({\n          marker: 'C',\n          values: [].concat(topRight1, [x1, y0], topRight2)\n        });\n        commands.push({\n          marker: 'L',\n          values: topRight2\n        });\n      } else {\n        commands.push({\n          marker: 'L',\n          values: [x1, y0]\n        });\n      }\n\n      commands.push({\n        marker: 'Z',\n        values: []\n      });\n      return commands;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"commandsToSvgPath\", function (commands) {\n      return commands.map(function (command) {\n        return \"\".concat(command.marker, \" \").concat(command.values.join(','));\n      }).join(' ').trim();\n    });\n\n    return _this;\n  }\n\n  _createClass(StackedBarGrouped, [{\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var _event$nativeEvent$la = event.nativeEvent.layout,\n          height = _event$nativeEvent$la.height,\n          width = _event$nativeEvent$la.width;\n      this.setState({\n        height: height,\n        width: width\n      });\n    }\n  }, {\n    key: \"calcXScale\",\n    value: function calcXScale(domain) {\n      var _this$props = this.props,\n          horizontal = _this$props.horizontal,\n          _this$props$contentIn = _this$props.contentInset,\n          _this$props$contentIn2 = _this$props$contentIn.left,\n          left = _this$props$contentIn2 === void 0 ? 0 : _this$props$contentIn2,\n          _this$props$contentIn3 = _this$props$contentIn.right,\n          right = _this$props$contentIn3 === void 0 ? 0 : _this$props$contentIn3,\n          spacingInner = _this$props.spacingInner,\n          spacingOuter = _this$props.spacingOuter;\n      var width = this.state.width;\n\n      if (horizontal) {\n        return scale.scaleLinear().domain(domain).range([left, width - right]);\n      }\n\n      return scale.scaleBand().domain(domain).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n  }, {\n    key: \"calcYScale\",\n    value: function calcYScale(domain) {\n      var _this$props2 = this.props,\n          horizontal = _this$props2.horizontal,\n          _this$props2$contentI = _this$props2.contentInset,\n          _this$props2$contentI2 = _this$props2$contentI.top,\n          top = _this$props2$contentI2 === void 0 ? 0 : _this$props2$contentI2,\n          _this$props2$contentI3 = _this$props2$contentI.bottom,\n          bottom = _this$props2$contentI3 === void 0 ? 0 : _this$props2$contentI3,\n          spacingInner = _this$props2.spacingInner,\n          spacingOuter = _this$props2.spacingOuter;\n      var height = this.state.height;\n\n      if (horizontal) {\n        return scale.scaleBand().domain(domain).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n      }\n\n      return scale.scaleLinear().domain(domain).range([height - bottom, top]);\n    }\n  }, {\n    key: \"calcAreas\",\n    value: function calcAreas(x, y, series) {\n      var _this2 = this;\n\n      var _this$props3 = this.props,\n          horizontal = _this$props3.horizontal,\n          colors = _this$props3.colors,\n          keys = _this$props3.keys,\n          data = _this$props3.data,\n          initialBorderRadius = _this$props3.borderRadius,\n          innerBarSpace = _this$props3.innerBarSpace;\n      var areas;\n      var barWidth;\n\n      if (horizontal) {\n        barWidth = y.bandwidth() / data.length;\n        areas = series.map(function (stack, stackIndex) {\n          return stack.map(function (serie, keyIndex) {\n            return serie.map(function (entry, entryIndex) {\n              var leftMargin = series.length > 1 ? innerBarSpace / 2 : 0;\n              var path = shape.area().x0(function (d) {\n                return x(d[0]);\n              }).x1(function (d) {\n                return x(d[1]);\n              }).y(function (d, _index) {\n                return (_index === 0 ? y(entryIndex) + barWidth * stackIndex + leftMargin : y(entryIndex) + barWidth + barWidth * stackIndex) - leftMargin;\n              }).defined(function (d) {\n                return !isNaN(d[0]) && !isNaN(d[1]);\n              })([entry, entry]);\n              return {\n                path: path,\n                color: colors[stackIndex][keyIndex],\n                key: keys[stackIndex][keyIndex]\n              };\n            });\n          });\n        });\n      } else {\n        barWidth = x.bandwidth() / data.length;\n        areas = series.map(function (stack, stackIndex) {\n          return stack.map(function (serie, keyIndex) {\n            return serie.map(function (entry, entryIndex) {\n              var leftMargin = series.length > 1 ? innerBarSpace / 2 : 0;\n              var x0 = x(entryIndex) + barWidth * stackIndex + leftMargin;\n              var x1 = x(entryIndex) + barWidth + barWidth * stackIndex - leftMargin;\n              var y0 = y(entry[1]);\n              var y1 = y(entry[0]);\n              var barHeight = y1 - y0;\n              var borderRadius = initialBorderRadius * 2 > barHeight ? barHeight / 2 : initialBorderRadius;\n              var showTopBorder = keyIndex === stack.length - 1;\n              var showBottomBorder = keyIndex === 0;\n\n              var commands = _this2.coordinatesToPathCommands(x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder);\n\n              return {\n                path: _this2.commandsToSvgPath(commands),\n                color: colors[stackIndex][keyIndex],\n                key: keys[stackIndex][keyIndex]\n              };\n            });\n          });\n        });\n      }\n\n      return array.merge(areas);\n    }\n  }, {\n    key: \"calcExtent\",\n    value: function calcExtent(values) {\n      var _this$props4 = this.props,\n          gridMax = _this$props4.gridMax,\n          gridMin = _this$props4.gridMin;\n      var mergedValues = array.merge(values);\n      return array.extent([].concat(_toConsumableArray(mergedValues), [gridMin, gridMax]));\n    }\n  }, {\n    key: \"calcIndexes\",\n    value: function calcIndexes() {\n      var data = this.props.data;\n      return data[0].data.map(function (_, index) {\n        return index;\n      });\n    }\n  }, {\n    key: \"getSeries\",\n    value: function getSeries() {\n      var _this$props5 = this.props,\n          data = _this$props5.data,\n          keys = _this$props5.keys,\n          offset = _this$props5.offset,\n          order = _this$props5.order,\n          valueAccessor = _this$props5.valueAccessor;\n      return data.map(function (obj, index) {\n        return shape.stack().keys(keys[index]).value(function (item, key) {\n          return valueAccessor({\n            item: item,\n            key: key\n          });\n        }).order(order).offset(offset)(obj.data);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          animate = _this$props6.animate,\n          animationDuration = _this$props6.animationDuration,\n          style = _this$props6.style,\n          numberOfTicks = _this$props6.numberOfTicks,\n          children = _this$props6.children,\n          horizontal = _this$props6.horizontal;\n      var _this$state = this.state,\n          height = _this$state.height,\n          width = _this$state.width;\n\n      if (data.length === 0) {\n        return React.createElement(View, {\n          style: style\n        });\n      }\n\n      var series = this.getSeries();\n      var values = array.merge(array.merge(series));\n      var indexes = this.calcIndexes(values);\n      var extent = this.calcExtent(values);\n      var ticks = array.ticks(extent[0], extent[1], numberOfTicks);\n      var xDomain = horizontal ? extent : indexes;\n      var yDomain = horizontal ? indexes : extent;\n      var x = this.calcXScale(xDomain);\n      var y = this.calcYScale(yDomain);\n      var bandwidth = horizontal ? y.bandwidth() : x.bandwidth();\n      var stacks = this.calcAreas(x, y, series);\n      var extraProps = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        ticks: ticks,\n        data: data,\n        bandwidth: bandwidth\n      };\n      return React.createElement(View, {\n        style: style\n      }, React.createElement(View, {\n        style: {\n          flex: 1\n        },\n        onLayout: function onLayout(event) {\n          return _this3._onLayout(event);\n        }\n      }, height > 0 && width > 0 && React.createElement(Svg, {\n        style: {\n          height: height,\n          width: width\n        }\n      }, React.Children.map(children, function (child) {\n        if (child && child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n\n        return null;\n      }), stacks.map(function (areas, indexStack) {\n        var areaIndex = indexStack % data.length;\n        return areas.map(function (bar, indexArea) {\n          var keyIndex = indexArea % data[areaIndex].data.length;\n          var key = \"\".concat(areaIndex, \"-\").concat(keyIndex, \"-\").concat(bar.key);\n          var svg = data[areaIndex].data[keyIndex][bar.key].svg;\n          return React.createElement(Path, _extends({\n            key: key,\n            fill: bar.color\n          }, svg, {\n            d: bar.path,\n            animate: animate,\n            animationDuration: animationDuration\n          }));\n        });\n      }), React.Children.map(children, function (child) {\n        if (child && !child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n\n        return null;\n      }))));\n    }\n  }]);\n\n  return StackedBarGrouped;\n}(PureComponent);\n\nStackedBarGrouped.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.object),\n  keys: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n  offset: PropTypes.func,\n  order: PropTypes.func,\n  style: PropTypes.any,\n  spacingInner: PropTypes.number,\n  spacingOuter: PropTypes.number,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  contentInset: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number\n  }),\n  gridMin: PropTypes.number,\n  gridMax: PropTypes.number,\n  valueAccessor: PropTypes.func,\n  borderRadius: PropTypes.number,\n  innerBarSpace: PropTypes.number\n};\nStackedBarGrouped.defaultProps = {\n  spacingInner: 0.05,\n  spacingOuter: 0.05,\n  offset: shape.stackOffsetNone,\n  order: shape.stackOrderNone,\n  width: 100,\n  height: 100,\n  showZeroAxis: true,\n  contentInset: {},\n  numberOfTicks: 10,\n  showGrid: true,\n  valueAccessor: function valueAccessor(_ref) {\n    var item = _ref.item,\n        key = _ref.key;\n    return item[key];\n  },\n  borderRadius: 0,\n  innerBarSpace: 0\n};\nexport default StackedBarGrouped;","map":{"version":3,"sources":["stacked-bar-grouped.js"],"names":["width","height","_onLayout","nativeEvent","layout","calcXScale","contentInset","left","right","spacingOuter","scale","calcYScale","top","bottom","calcAreas","borderRadius","innerBarSpace","barWidth","y","data","areas","leftMargin","series","path","shape","d","x","_index","isNaN","color","colors","key","keys","x0","x1","y0","entry","y1","barHeight","initialBorderRadius","showTopBorder","keyIndex","stack","showBottomBorder","commands","array","marker","values","topLeft1","topLeft2","bottomLeft1","bottomLeft2","bottomRight1","bottomRight2","topRight1","topRight2","command","calcExtent","gridMin","mergedValues","calcIndexes","getSeries","valueAccessor","item","obj","render","horizontal","style","indexes","extent","ticks","xDomain","yDomain","bandwidth","stacks","extraProps","flex","event","child","React","areaIndex","indexStack","indexArea","bar","svg","animationDuration","StackedBarGrouped","PropTypes","offset","order","spacingInner","animate","number","gridMax","showZeroAxis","numberOfTicks","showGrid"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react'\nimport { View } from 'react-native'\nimport PropTypes from 'prop-types'\nimport Svg from 'react-native-svg'\nimport * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport Path from '../animated-path'\n\nclass StackedBarGrouped extends PureComponent {\n    state = {\n        width: 0,\n        height: 0,\n    }\n\n    _onLayout(event) {\n        const {\n            nativeEvent: {\n                layout: { height, width },\n            },\n        } = event\n        this.setState({ height, width })\n    }\n\n    calcXScale(domain) {\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n        }\n\n        return scale\n            .scaleBand()\n            .domain(domain)\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const {\n            horizontal,\n            contentInset: { top = 0, bottom = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(domain)\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n    }\n\n    calcAreas(x, y, series) {\n        const { horizontal, colors, keys, data, borderRadius: initialBorderRadius, innerBarSpace } = this.props\n        let areas\n        let barWidth\n\n        if (horizontal) {\n            barWidth = y.bandwidth() / data.length\n\n            areas = series.map((stack, stackIndex) => {\n                return stack.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const leftMargin = series.length > 1 ? innerBarSpace / 2 : 0\n\n                        const path = shape\n                            .area()\n                            .x0((d) => x(d[0]))\n                            .x1((d) => x(d[1]))\n                            .y(\n                                (d, _index) =>\n                                    (_index === 0\n                                        ? y(entryIndex) + barWidth * stackIndex + leftMargin\n                                        : y(entryIndex) + barWidth + barWidth * stackIndex) - leftMargin\n                            )\n                            .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                        return {\n                            path,\n                            color: colors[stackIndex][keyIndex],\n                            key: keys[stackIndex][keyIndex],\n                        }\n                    })\n                })\n            })\n        } else {\n            barWidth = x.bandwidth() / data.length\n\n            areas = series.map((stack, stackIndex) => {\n                return stack.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const leftMargin = series.length > 1 ? innerBarSpace / 2 : 0\n                        const x0 = x(entryIndex) + barWidth * stackIndex + leftMargin\n                        const x1 = x(entryIndex) + barWidth + barWidth * stackIndex - leftMargin\n                        const y0 = y(entry[1])\n                        const y1 = y(entry[0])\n                        const barHeight = y1 - y0\n                        const borderRadius = initialBorderRadius * 2 > barHeight ? barHeight / 2 : initialBorderRadius\n                        const showTopBorder = keyIndex === stack.length - 1\n                        const showBottomBorder = keyIndex === 0\n                        const commands = this.coordinatesToPathCommands(\n                            x0,\n                            y0,\n                            x1,\n                            y1,\n                            borderRadius,\n                            showTopBorder,\n                            showBottomBorder\n                        )\n\n                        return {\n                            path: this.commandsToSvgPath(commands),\n                            color: colors[stackIndex][keyIndex],\n                            key: keys[stackIndex][keyIndex],\n                        }\n                    })\n                })\n            })\n        }\n\n        return array.merge(areas)\n    }\n\n    coordinatesToPathCommands = (x0, y0, x1, y1, borderRadius, showTopBorder, showBottomBorder) => {\n        const commands = []\n        commands.push({ marker: 'M', values: [x0, y0] })\n\n        if (showTopBorder) {\n            const topLeft1 = [x0 + borderRadius, y0]\n            const topLeft2 = [x0, y0 + borderRadius]\n            commands.push({ marker: 'L', values: topLeft1 })\n            commands.push({\n                marker: 'C',\n                values: [...topLeft1, x0, y0, ...topLeft2],\n            })\n            commands.push({ marker: 'L', values: topLeft2 })\n        } else {\n            commands.push({ marker: 'L', values: [x0, y0] })\n        }\n\n        if (showBottomBorder) {\n            const bottomLeft1 = [x0, y1 - borderRadius]\n            const bottomLeft2 = [x0 + borderRadius, y1]\n            commands.push({ marker: 'L', values: bottomLeft1 })\n            commands.push({\n                marker: 'C',\n                values: [...bottomLeft1, x0, y1, ...bottomLeft2],\n            })\n            commands.push({ marker: 'L', values: bottomLeft2 })\n            const bottomRight1 = [x1 - borderRadius, y1]\n            const bottomRight2 = [x1, y1 - borderRadius]\n            commands.push({ marker: 'L', values: bottomRight1 })\n            commands.push({\n                marker: 'C',\n                values: [...bottomRight1, x1, y1, ...bottomRight2],\n            })\n            commands.push({ marker: 'L', values: bottomRight2 })\n        } else {\n            commands.push({ marker: 'L', values: [x0, y1] })\n            commands.push({ marker: 'L', values: [x1, y1] })\n        }\n\n        if (showTopBorder) {\n            const topRight1 = [x1, y0 + borderRadius]\n            const topRight2 = [x1 - borderRadius, y0]\n\n            commands.push({ marker: 'L', values: topRight1 })\n            commands.push({\n                marker: 'C',\n                values: [...topRight1, x1, y0, ...topRight2],\n            })\n            commands.push({ marker: 'L', values: topRight2 })\n        } else {\n            commands.push({ marker: 'L', values: [x1, y0] })\n        }\n\n        commands.push({ marker: 'Z', values: [] })\n\n        return commands\n    }\n\n    commandsToSvgPath = (commands) =>\n        commands\n            .map((command) => `${command.marker} ${command.values.join(',')}`)\n            .join(' ')\n            .trim()\n\n    calcExtent(values) {\n        const { gridMax, gridMin } = this.props\n\n        // One more merge for stacked groups\n        const mergedValues = array.merge(values)\n\n        return array.extent([...mergedValues, gridMin, gridMax])\n    }\n\n    calcIndexes() {\n        const { data } = this.props\n\n        // Must return an array with indexes for the number of groups to be shown\n        return data[0].data.map((_, index) => index)\n    }\n\n    getSeries() {\n        const { data, keys, offset, order, valueAccessor } = this.props\n\n        return data.map((obj, index) =>\n            shape\n                .stack()\n                .keys(keys[index])\n                .value((item, key) => valueAccessor({ item, key }))\n                .order(order)\n                .offset(offset)(obj.data)\n        )\n    }\n\n    render() {\n        const { data, animate, animationDuration, style, numberOfTicks, children, horizontal } = this.props\n\n        const { height, width } = this.state\n\n        if (data.length === 0) {\n            return <View style={style} />\n        }\n\n        const series = this.getSeries()\n\n        //double merge arrays to extract just the values\n        const values = array.merge(array.merge(series))\n        const indexes = this.calcIndexes(values)\n\n        const extent = this.calcExtent(values)\n        const ticks = array.ticks(extent[0], extent[1], numberOfTicks)\n\n        const xDomain = horizontal ? extent : indexes\n        const yDomain = horizontal ? indexes : extent\n\n        const x = this.calcXScale(xDomain)\n        const y = this.calcYScale(yDomain)\n\n        const bandwidth = horizontal ? y.bandwidth() : x.bandwidth()\n\n        const stacks = this.calcAreas(x, y, series)\n\n        const extraProps = {\n            x,\n            y,\n            width,\n            height,\n            ticks,\n            data,\n            bandwidth,\n        }\n\n        return (\n            <View style={style}>\n                <View style={{ flex: 1 }} onLayout={(event) => this._onLayout(event)}>\n                    {height > 0 && width > 0 && (\n                        <Svg style={{ height, width }}>\n                            {React.Children.map(children, (child) => {\n                                if (child && child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                            {stacks.map((areas, indexStack) => {\n                                const areaIndex = indexStack % data.length\n\n                                return areas.map((bar, indexArea) => {\n                                    const keyIndex = indexArea % data[areaIndex].data.length\n                                    const key = `${areaIndex}-${keyIndex}-${bar.key}`\n\n                                    const { svg } = data[areaIndex].data[keyIndex][bar.key]\n\n                                    return (\n                                        <Path\n                                            key={key}\n                                            fill={bar.color}\n                                            {...svg}\n                                            d={bar.path}\n                                            animate={animate}\n                                            animationDuration={animationDuration}\n                                        />\n                                    )\n                                })\n                            })}\n                            {React.Children.map(children, (child) => {\n                                if (child && !child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                        </Svg>\n                    )}\n                </View>\n            </View>\n        )\n    }\n}\n\nStackedBarGrouped.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.object),\n    keys: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n    colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)).isRequired,\n    offset: PropTypes.func,\n    order: PropTypes.func,\n    style: PropTypes.any,\n    spacingInner: PropTypes.number,\n    spacingOuter: PropTypes.number,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    contentInset: PropTypes.shape({\n        top: PropTypes.number,\n        left: PropTypes.number,\n        right: PropTypes.number,\n        bottom: PropTypes.number,\n    }),\n    gridMin: PropTypes.number,\n    gridMax: PropTypes.number,\n    valueAccessor: PropTypes.func,\n    borderRadius: PropTypes.number,\n    innerBarSpace: PropTypes.number,\n}\n\nStackedBarGrouped.defaultProps = {\n    spacingInner: 0.05,\n    spacingOuter: 0.05,\n    offset: shape.stackOffsetNone,\n    order: shape.stackOrderNone,\n    width: 100,\n    height: 100,\n    showZeroAxis: true,\n    contentInset: {},\n    numberOfTicks: 10,\n    showGrid: true,\n    valueAccessor: ({ item, key }) => item[key],\n    borderRadius: 0,\n    innerBarSpace: 0,\n}\n\nexport default StackedBarGrouped\n"]},"metadata":{},"sourceType":"module"}