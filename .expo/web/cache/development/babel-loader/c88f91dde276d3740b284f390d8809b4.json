{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport PropTypes from 'prop-types';\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport BarChart from \"./bar-chart\";\n\nvar GroupedBarChart = function (_BarChart) {\n  _inherits(GroupedBarChart, _BarChart);\n\n  var _super = _createSuper(GroupedBarChart);\n\n  function GroupedBarChart() {\n    _classCallCheck(this, GroupedBarChart);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GroupedBarChart, [{\n    key: \"calcXScale\",\n    value: function calcXScale(domain) {\n      var _this$props = this.props,\n          horizontal = _this$props.horizontal,\n          _this$props$contentIn = _this$props.contentInset,\n          _this$props$contentIn2 = _this$props$contentIn.left,\n          left = _this$props$contentIn2 === void 0 ? 0 : _this$props$contentIn2,\n          _this$props$contentIn3 = _this$props$contentIn.right,\n          right = _this$props$contentIn3 === void 0 ? 0 : _this$props$contentIn3,\n          spacingInner = _this$props.spacingInner,\n          spacingOuter = _this$props.spacingOuter,\n          clamp = _this$props.clamp;\n      var width = this.state.width;\n\n      if (horizontal) {\n        return scale.scaleLinear().domain(domain).range([left, width - right]).clamp(clamp);\n      }\n\n      return scale.scaleBand().domain(domain).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n  }, {\n    key: \"calcYScale\",\n    value: function calcYScale(domain) {\n      var _this$props2 = this.props,\n          horizontal = _this$props2.horizontal,\n          spacingInner = _this$props2.spacingInner,\n          spacingOuter = _this$props2.spacingOuter,\n          _this$props2$contentI = _this$props2.contentInset,\n          _this$props2$contentI2 = _this$props2$contentI.top,\n          top = _this$props2$contentI2 === void 0 ? 0 : _this$props2$contentI2,\n          _this$props2$contentI3 = _this$props2$contentI.bottom,\n          bottom = _this$props2$contentI3 === void 0 ? 0 : _this$props2$contentI3,\n          clamp = _this$props2.clamp;\n      var height = this.state.height;\n\n      if (horizontal) {\n        return scale.scaleBand().domain(domain).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n      }\n\n      return scale.scaleLinear().domain(domain).range([height - bottom, top]).clamp(clamp);\n    }\n  }, {\n    key: \"calcAreas\",\n    value: function calcAreas(x, y) {\n      var _this$props3 = this.props,\n          horizontal = _this$props3.horizontal,\n          data = _this$props3.data,\n          yAccessor = _this$props3.yAccessor;\n\n      var _data = data.map(function (obj) {\n        var _obj$svg = obj.svg,\n            svg = _obj$svg === void 0 ? {} : _obj$svg;\n        return _objectSpread({}, obj, {\n          data: obj.data.map(function (item) {\n            if (typeof item === 'number') {\n              return {\n                value: item,\n                svg: svg\n              };\n            }\n\n            return _objectSpread({}, item, {\n              svg: _objectSpread({}, svg, {}, item.svg),\n              value: yAccessor({\n                item: item\n              })\n            });\n          })\n        });\n      });\n\n      var areas = [];\n\n      if (horizontal) {\n        var barWidth = y.bandwidth() / data.length;\n\n        _data.forEach(function (obj, collectionIndex) {\n          obj.data.forEach(function (item, valueIndex) {\n            areas.push({\n              bar: item,\n              path: shape.area().y(function (value, _index) {\n                return _index === 0 ? y(valueIndex) + barWidth * collectionIndex : y(valueIndex) + barWidth + barWidth * collectionIndex;\n              }).x0(x(0)).x1(function (value) {\n                return x(value);\n              }).defined(function (value) {\n                return typeof value === 'number';\n              })([item.value, item.value])\n            });\n          });\n        });\n      } else {\n        var _barWidth = x.bandwidth() / data.length;\n\n        _data.forEach(function (obj, collectionIndex) {\n          obj.data.forEach(function (item, valueIndex) {\n            areas.push({\n              bar: item,\n              path: shape.area().x(function (value, _index) {\n                return _index === 0 ? x(valueIndex) + _barWidth * collectionIndex : x(valueIndex) + _barWidth + _barWidth * collectionIndex;\n              }).y0(y(0)).y1(function (value) {\n                return y(value);\n              }).defined(function (value) {\n                return typeof value === 'number';\n              })([item.value, item.value])\n            });\n          });\n        });\n      }\n\n      return areas;\n    }\n  }, {\n    key: \"calcExtent\",\n    value: function calcExtent() {\n      var _this$props4 = this.props,\n          data = _this$props4.data,\n          yAccessor = _this$props4.yAccessor,\n          gridMin = _this$props4.gridMin,\n          gridMax = _this$props4.gridMax;\n      var dataExtent = array.merge(data.map(function (obj) {\n        return obj.data.map(function (item) {\n          return yAccessor({\n            item: item\n          });\n        });\n      }));\n      var extent = array.extent([].concat(_toConsumableArray(dataExtent), [gridMax, gridMin]));\n      var _this$props5 = this.props,\n          _this$props5$yMin = _this$props5.yMin,\n          yMin = _this$props5$yMin === void 0 ? extent[0] : _this$props5$yMin,\n          _this$props5$yMax = _this$props5.yMax,\n          yMax = _this$props5$yMax === void 0 ? extent[1] : _this$props5$yMax;\n      return [yMin, yMax];\n    }\n  }, {\n    key: \"calcIndexes\",\n    value: function calcIndexes() {\n      var data = this.props.data;\n      return data[0].data.map(function (_, index) {\n        return index;\n      });\n    }\n  }]);\n\n  return GroupedBarChart;\n}(BarChart);\n\nGroupedBarChart.propTypes = _objectSpread({}, BarChart.propTypes, {\n  data: PropTypes.arrayOf(PropTypes.shape({\n    data: PropTypes.array.isRequired,\n    svg: PropTypes.object\n  })).isRequired\n});\nexport default GroupedBarChart;","map":{"version":3,"sources":["bar-chart-grouped.js"],"names":["calcXScale","contentInset","left","right","clamp","width","scale","calcYScale","top","bottom","height","calcAreas","yAccessor","_data","obj","svg","data","item","value","areas","barWidth","y","bar","path","shape","_index","x","calcExtent","gridMax","dataExtent","extent","array","yMin","yMax","calcIndexes","GroupedBarChart","BarChart","PropTypes","object","isRequired"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types'\nimport * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport BarChart from './bar-chart'\n\nclass GroupedBarChart extends BarChart {\n    calcXScale(domain) {\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n            clamp,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n                .clamp(clamp)\n        }\n\n        return scale\n            .scaleBand()\n            .domain(domain)\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const {\n            horizontal,\n            spacingInner,\n            spacingOuter,\n            contentInset: { top = 0, bottom = 0 },\n            clamp,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(domain)\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n            .clamp(clamp)\n    }\n\n    calcAreas(x, y) {\n        const { horizontal, data, yAccessor } = this.props\n\n        const _data = data.map((obj) => {\n            const { svg = {} } = obj\n            return {\n                ...obj,\n                data: obj.data.map((item) => {\n                    if (typeof item === 'number') {\n                        return {\n                            value: item,\n                            svg,\n                        }\n                    }\n\n                    return {\n                        ...item,\n                        svg: {\n                            ...svg,\n                            ...item.svg,\n                        },\n                        value: yAccessor({ item }),\n                    }\n                }),\n            }\n        })\n\n        const areas = []\n\n        if (horizontal) {\n            const barWidth = y.bandwidth() / data.length\n\n            _data.forEach((obj, collectionIndex) => {\n                obj.data.forEach((item, valueIndex) => {\n                    areas.push({\n                        bar: item,\n                        path: shape\n                            .area()\n                            .y((value, _index) =>\n                                _index === 0\n                                    ? y(valueIndex) + barWidth * collectionIndex\n                                    : y(valueIndex) + barWidth + barWidth * collectionIndex\n                            )\n                            .x0(x(0))\n                            .x1((value) => x(value))\n                            .defined((value) => typeof value === 'number')([item.value, item.value]),\n                    })\n                })\n            })\n        } else {\n            const barWidth = x.bandwidth() / data.length\n\n            _data.forEach((obj, collectionIndex) => {\n                obj.data.forEach((item, valueIndex) => {\n                    areas.push({\n                        bar: item,\n                        path: shape\n                            .area()\n                            .x((value, _index) =>\n                                _index === 0\n                                    ? x(valueIndex) + barWidth * collectionIndex\n                                    : x(valueIndex) + barWidth + barWidth * collectionIndex\n                            )\n                            .y0(y(0))\n                            .y1((value) => y(value))\n                            .defined((value) => typeof value === 'number')([item.value, item.value]),\n                    })\n                })\n            })\n        }\n\n        return areas\n    }\n\n    calcExtent() {\n        const { data, yAccessor, gridMin, gridMax } = this.props\n        const dataExtent = array.merge(data.map((obj) => obj.data.map((item) => yAccessor({ item }))))\n\n        const extent = array.extent([...dataExtent, gridMax, gridMin])\n\n        const { yMin = extent[0], yMax = extent[1] } = this.props\n\n        return [yMin, yMax]\n    }\n\n    calcIndexes() {\n        const { data } = this.props\n        return data[0].data.map((_, index) => index)\n    }\n}\n\nGroupedBarChart.propTypes = {\n    ...BarChart.propTypes,\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            data: PropTypes.array.isRequired,\n            svg: PropTypes.object,\n        })\n    ).isRequired,\n}\n\nexport default GroupedBarChart\n"]},"metadata":{},"sourceType":"module"}